import math, time
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def assemble_matrix(n, L, k, qg, T0, h, Ta):
    dx = L / n
    a = -k / dx**2
    b = 2*k / dx**2
    c = -k / dx**2

    A = np.zeros((n,n))
    rhs = np.zeros(n)

    for i in range(n):
        if i == 0:
            A[i,i] = b
            A[i,i+1] = c
            rhs[i] = qg - a * T0
       
        elif i == n - 1:
            A[i,i-1] = -k/dx
            A[i,i] = k/dx + h
            rhs[i] = h * Ta
        
        else:
            A[i,i-1] = a
            A[i,i]   = b
            A[i,i+1] = c
            rhs[i] = qg

    return A, rhs, dx

def gauss_jordan(Aorig, borig, tol=1e-12):
    A = Aorig.astype(float).copy()
    b = borig.astype(float).copy()
    n = A.shape[0]

    aug = np.hstack([A, b.reshape(-1,1)])

    for col in range(n):
        pivot_row = np.argmax(np.abs(aug[col:, col])) + col
        if abs(aug[pivot_row, col]) < tol:
            raise ValueError("Pivot casi cero")

        if pivot_row != col:
            aug[[col, pivot_row]] = aug[[pivot_row, col]]

        aug[col] = aug[col] / aug[col, col]

        for r in range(n):
            if r == col: 
                continue
            factor = aug[r, col]
            aug[r] = aug[r] - factor * aug[col]

    x = aug[:, -1]
    return x

def lu_doolittle(A):
    n = A.shape[0]
    L = np.eye(n)
    U = np.zeros((n,n))

    for i in range(n):
        for k in range(i, n):
            U[i,k] = A[i,k] - sum(L[i,j] * U[j,k] for j in range(i))

        for k in range(i+1, n):
            if abs(U[i,i]) < 1e-15:
                raise ValueError("Pivot nulo en LU")

            L[k,i] = (A[k,i] - sum(L[k,j] * U[j,i] for j in range(i))) / U[i,i]

    return L, U

def lu_solve(L, U, b):
    n = L.shape[0]
    y = np.zeros(n)
    for i in range(n):
        y[i] = b[i] - sum(L[i,j] * y[j] for j in range(i))

    x = np.zeros(n)
    for i in range(n-1, -1, -1):
        x[i] = (y[i] - sum(U[i,j] * x[j] for j in range(i+1, n))) / U[i,i]

    return x

def gauss_seidel(A, b, x0=None, tol=1e-10, maxit=100000):
    n = A.shape[0]
    x = np.zeros(n) if x0 is None else x0.copy()

    for it in range(maxit):
        x_old = x.copy()

        for i in range(n):
            s1 = np.dot(A[i,:i], x[:i])
            s2 = np.dot(A[i,i+1:], x_old[i+1:])
            x[i] = (b[i] - s1 - s2) / A[i,i]

        if np.linalg.norm(x - x_old, np.inf) < tol:
            return x, it+1

    raise RuntimeError("Gauss-Seidel no convergiÃ³")
n = 10
L = 1.0
k = 0.5
qg = 1000.0
T0 = 300.0
h  = 50.0
Ta = 298.0

A, rhs, dx = assemble_matrix(n, L, k, qg, T0, h, Ta)
x_positions = np.linspace(dx, L, n)

x_gj = gauss_jordan(A, rhs)

Lmat, Umat = lu_doolittle(A)
x_lu = lu_solve(Lmat, Umat, rhs)

x_gs, iters = gauss_seidel(A, rhs)


print("=== RESULTADOS ===")
print("Gauss-Jordan:\n", x_gj)
print("\nLU:\n", x_lu)
print("\nGauss-Seidel (iters={}):\n".format(iters), x_gs)

print("\nDiferencias (norma infinito)")
print(" |GJ - LU|:", np.linalg.norm(x_gj - x_lu, np.inf))
print(" |GJ - GS|:", np.linalg.norm(x_gj - x_gs, np.inf))
print(" |LU - GS|:", np.linalg.norm(x_lu - x_gs, np.inf))

plt.plot(x_positions, x_gj, "-o", label="Gauss-Jordan")
plt.plot(x_positions, x_lu, "-s", label="LU")
plt.plot(x_positions, x_gs, "-^", label="Gauss-Seidel")
plt.xlabel("x (m)")
plt.ylabel("Temperatura (K)")
plt.grid(True)
plt.legend()
plt.show()
